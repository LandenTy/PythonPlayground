import { outputEl, currentURL, promptInputs } from './terminal.js';

/**
 * Wrap raw user Java code into a valid Main class
 */
function wrapJavaCode(userCode) {
    return `
import java.util.*;

public class Main {
    public static void main(String[] args) {
${userCode.split('\n').map(line => '        ' + line).join('\n')}
    }
}
`;
}

/**
 * Execute Java code using the Piston API
 */
async function executeCode(code, inputs = []) {
    outputEl.textContent = "ðŸ”„ " + currentURL + "/Main.java";

    try {
        const response = await fetch("https://emkc.org/api/v2/piston/execute", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                language: "java",
                version: "17",
                files: [
                    {
                        name: "Main.java",
                        content: code
                    }
                ],
                stdin: inputs.join("\n")
            })
        });

        if (!response.ok) {
            throw new Error("Error executing Java code");
        }

        const result = await response.json();
        const output = result.run.output?.trim() || "âš  No output";

        outputEl.innerHTML += `<br>> ${output.replace(/\n/g, "<br>")}`;
    } catch (error) {
        outputEl.innerHTML += `<br>âš  ${error.message}`;
    }
}

/**
 * Compile / run Java code from editor
 */
async function compileCode(editor) {
    outputEl.innerHTML = "";

    const rawCode = editor.getValue();

    // Detect Scanner input usage
    const inputPattern = /(Scanner\s+\w+\s*=\s*new\s+Scanner|next(Line|Int|Double)\s*\()/g;
    const needsInput = inputPattern.test(rawCode);

    let wrappedCode = wrapJavaCode(rawCode);

    if (!needsInput) {
        await executeCode(wrappedCode);
        return;
    }

    // Prompt user for input values
    promptInputs(
        ["Program input (each line = one Scanner read)"],
        (inputs) => executeCode(wrappedCode, inputs),
        outputEl,
        wrappedCode
    );
}

export { compileCode, executeCode };
